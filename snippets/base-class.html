<html>
  <body>
    <h1>Usage as a web component base class</h1>
    <h2>Open your console ðŸ˜‰</h2>
    <my-element></my-element>
    <script>
      /* We create a new class that extends from the native HTMLElement */
      class BatchingElement extends HTMLElement {
        constructor() {

          /* We now have to call `super` to make sure our element gets set up correctly */
          super();
          this.updateComplete = this.__createDeferredPromise();
        }

        async requestUpdate() {
          if (!this.updateRequested) {
            this.updateRequested = true;
            this.updateRequested = await false;
            this.update();
            this.__resolve();
            this.updateComplete = this.__createDeferredPromise();
          }
        }

        update() {}

        __createDeferredPromise() {
          return new Promise((resolve) => {
            this.__resolve = resolve;
          });
        }
      }

      /* We create a new class, MyElement, that extends from our BatchingElement base class */
      class MyElement extends BatchingElement {

        constructor() {
          super();

          /* We attach a shadowRoot to our component for good measure */
          this.attachShadow({ mode: "open" });
        }

        connectedCallback() {
          /* And we call an initial render when our component gets connected to the DOM */
          this.update();
        }

        /**
         * This is our `update` function that will get triggered by the
         * `requestUpdate` method.
         *
         * Any time we set a property on this element, we'll also
         * trigger an update.
         */
        update() {
          console.log('updating!');
          this.shadowRoot.innerHTML = `
            <div>value of a: ${this.a}</div>
            <div>value of b: ${this.b}</div>
          `;
        }

        /**
         * And finally, we need some getters and setters to
         * actually be able to trigger updates ðŸ™ƒ
         *
         * Notice how much boilerplate this is, and how nice
         * LitElement makes this for us instead? ðŸ˜©
         */
        set a(val) {
          this.__a = val;
          this.requestUpdate();
        }
        get a(){
          return this.__a;
        }

        set b(val) {
          this.__b = val;
          this.requestUpdate();
        }
        get b(){
          return this.__b;
        }
      }

      customElements.define("my-element", MyElement);

      /* We get a reference to our component, so we can call methods on it */
      const myElement = document.querySelector('my-element');

      /**
       * We assign multiple properties in quick succession,
       * but our component will still only call `update` once!
       */
      myElement.a = 'foo';
      myElement.b = 'bar';

      /**
       * ðŸŽ‰ The result:
       * - "updating!" is logged to the console because of the call to `this.update()` in the `connectedCallback`
       * - "updating!" is logged only once, after setting both the `a` and `b` properties
       */
    </script>
  </body>
</html>